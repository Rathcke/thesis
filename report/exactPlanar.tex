\section{Exact Oracles in Directed Planar Graphs}\label{exactPlanar}

Previous works have given exact distance oracles for directed planar graphs of size
$O(n^{5/3})$ with query time $O(\lg n)$ \cite{cohen2017fast}. This was improved recently
to use $O(n^{3/2})$ space \cite{gawrychowski2017better}. In the general case, we have
bounds that depend on the number of vertices $n$. But in the vertex-labeled case, we can
sometimes win space or obtain better query times by depending on the number of labels $\ell$.

\subsection{A distance oracle depending on $\ell$}
We cannot directly adapt the approach used in \cite{cohen2017fast} and \cite{gawrychowski2017better} to work
for the vertex-labeled case as it requires us to know the "target" vertex. However,
depending on $\ell$, we can use the $r$-division alone to show the following:
\begin{thm}\label{thm1}
  There is a distance oracle with space $O(n\ell^{2/3)})$, query time $O(\ell^{1/3})$ and
  preprocessing time $O(n^2)$.
\end{thm}
\textit{Data structure}. Given a directed graph $G$ and a number of labels $\ell$, we
construct an $r$-division. Each region $R$ then has at most $r$ nodes and $O(\sqrt{r})$
boundary nodes. For each boundary node $u$, we store the shortest distance $d(u,\lambda)$
for all $\lambda \in L$ in a hash table. For all nodes inside $R$, we store the shortest
distance to all
boundary nodes as well as the distance to all labels present in $R$ in a hash table. \\
\\
\textit{Query}. Given the query $Q(v, \lambda)$, if $v$ is a boundary node, we can look
up the distance in the hash table for $v$. If $v$ is not a boundary node, look up the
distances $\delta(u,v)+\delta(u,\lambda)$ for all boundary nodes $u$ and the distance
$\delta(v,\lambda)$ stored in the hash table for $v$ and return the minimum.

\subsubsection{Analysis}
The $r$-division can be constructed in $O(n)$ time \cite{klein2013structured}. Henzinger
et al. showed that single source shortest paths can be computed in $O(n)$ time
\cite{henzinger1997faster} assuming non-negative edge lengths. This gives us a
preprocessing time of $O(n^2)$ TODO: Better preprocessing relying on $r$ or $\ell$. \\
\\
For each boundary node, we store the distance to all labels. The $r$-division gives us
$O(n/r)$ regions and ensures we
get $O(\sqrt{r})$ boundary nodes, so this yields
$O(\frac{n}{r}\sqrt{r}\ell)=O(\frac{n}{\sqrt{r}}\ell)$ space. For all other nodes, we
store the distances to all boundary nodes and to all labels within that region. This
gives us $O(nr)$ space as we can potentially store the distances to all vertices in a
region $R$. This gives us a total of $O(\frac{n}{\sqrt{r}}\ell+nr)$ space. \\
\\
The query $Q(u,\lambda)$ for a boundary node $u$ can be looked up in its hash table in
$O(1)$ time. For the query $Q(v,\lambda)$ for a vertex $v$ not on the boundary, we have
to find the minimum distance to $\lambda$ between all boundary nodes even if it exists in
that region as we are not guaranteed that the closest $\lambda$-labaled node is in the
region of $v$. Thus we have a query time of $O(\sqrt{r})$. \\
\\
This gives us a simple trade-off, since we can pick $r$ to be sufficiently small to
achieve constant query time, but this would give $O(n\ell)$ space. However, picking
$r=\ell^{2/3}$, gives us $O(n\ell^{2/3}+\frac{n}{\sqrt{\ell^{2/3}}}\ell)=O(n\ell^{2/3})$
space and query time $O(\sqrt{l^{2/3}})=O(\ell^{1/3})$. This gives us Theorem
$\ref{thm1}$.

\subsubsection{Recursion}
We can improve the trade-off slightly if we construct the $r$-division recursively. This will
yield space:
\begin{align*}
  \sum_{i=1}^{lg_{n/r}(n)} \left(\frac{n}{r}\right)^i
  \sqrt{r\left(\frac{r}{n}\right)^{i-1}} \min
  \left\{\ell,\left(n-r\right)\left(\frac{r}{n}\right)^{i-1}\right\}
\end{align*}
TODO: Not really worth it with recursion?

\subsection{A distance oracle with better query times}
We now present a distance oracle which is actually multiple data structures that perform
well depending on $\ell$ and the number of each $\lambda\in L$. We will refer to the
number of a given label by saying the \textit{size} of that label. Under the assumption
that $G$ does not have $\omega(\sqrt{n})$ labels of polynomial size, we can show the
following:
\begin{thm}\label{thm2}
  There is a distance oracle with space $O(n^{3/2})$, query time $O(\text{polylog}(n))$ and
  preprocessing time $O(n^2)$.
\end{thm}
\textit{Data structure}. Given the directed graph $G$ and a number of labels $\ell$ with
$\varepsilon_1 = O(\sqrt{n})$ and $\varepsilon_2=O(\text{polylog}(n))$, we divide our
data structure into the following three cases: \\
\\
\textbf{Case 1:} If $\ell\in [1, \varepsilon_1]$, simply store the matrix of all shortest paths for all nodes to all
labels in the graph. \\
\textbf{Case 2:} If $\ell\in [n-\varepsilon_2, n]$, we use the approach described in section
\ref{cohenplanar}. \\
\textbf{Case 3:} If $\ell\in (\varepsilon_1, n]$ and there are $\varepsilon_1$ number of labels that have
polynomial size, we mix
the above two approaches. That is, for labels of size $\varepsilon_2$, we use the
approach from section \ref{cohenplanar}. For labels of size polynomial, we store the
shortest path from every vertex to those labels in a hash table. Additionally, for each
label, we store the size of that label. \\
\\
\textit{Query}. Depending on the case that $G$ falls under, we do the following for the
query $Q(v, \lambda)$: \\
\\
\textbf{Case 1:} Look up the distance in the hash table stored for $v$. \\
\textbf{Case 2:} The query works in the same manner as described in section
\ref{cohenplanar}, however, we do not the target vertex. Therefore, we have to run over
all vertices with label $\lambda$ and return the minimal distance. \\
\textbf{Case 3:} First we look up the size of $\lambda$ in the hash table. If the size of
$\lambda$ is $\varepsilon_2$, we do the same as in case 2. If the size of $\lambda$ is
$\omega(\text{polylog}(n))$, we look up the distance stored in the hash table for $v$.

\subsubsection{Analysis}
Preprocessing can be done in $O(n^2)$ (all pairs shortest paths in planar graphs
dominating). TODO: better. \\
\\
In case 1, we store $\ell$ distances for each vertex $v$. Since $\ell=O(\sqrt{n})$, this
yields space $O(n^{3/2}$. \\
In case 2, space follows directly from \cite{gawrychowski2017better} as the construction
is identical, which is $O(n^{3/2})$. \\
In case 3, we perform the same construction as in \cite{gawrychowski2017better} requiring
in $O(n^{3/2})$ space. Additionally, since we assumed that there are no more that
$O(\sqrt{n})$ labels of size $\omega(\text{polylog}(n)$, the hash table storing the
distances to these labels cannot require more than $O(n^{3/2})$ space. The hash table
storing the size of all labels require $O(\ell)$ space, so the total space
in this case (and in any other case) is $O(n^{3/2})$.\\
\\
In case 1, we look up the distance in the hash table in $O(1)$ time.\\
In case 2, all labels have size $O(\text{polylog}(n))$. Since the point location desribed
in \cite{gawrychowski2017better} takes $O(\lg n)$ and we need to do at most
$O(\text{polylog}(n))$ of these point location, the total query time is
$O(\text{polylog}(n))$. \\
In case 3, we do a lookup in the hash table storing the sizes of each $\lambda\in L$ in
$O(1)$ time. Depending on the result, we either do the same thing as in case 1 or case 2,
thus we have a query time of $O(\text{polylog}(n))$. \\
\\
This gives us the distance oracle given in Theorem \ref{thm2}. \\
\\
TODO: Fix the gap ($\omega(\sqrt{n})$ labels with $\omega(\text{polylog}(n))$ size).

